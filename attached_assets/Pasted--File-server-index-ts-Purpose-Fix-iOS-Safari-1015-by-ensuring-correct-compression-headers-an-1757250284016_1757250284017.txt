// File: server/index.ts
// Purpose: Fix iOS Safari -1015 by ensuring correct compression/headers and add SPA history fallback for / and /mobile/*.

import express, { type Request, Response, NextFunction } from "express";
import compression from "compression";
import path from "node:path";
import history from "connect-history-api-fallback";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";

const app = express();

// --- Security & base middleware ---
app.disable("x-powered-by");
app.use((req, _res, next) => {  // why: consistent UTF-8; avoid stray encodings
  req.headers["accept-charset"] = "utf-8";
  next();
});

// --- Compression (safe, standards-compliant) ---
// why: Avoid custom content-encoding; ensures Safari sees body that matches header
app.use(
  compression({
    threshold: 1024,
  })
);

app.use(express.json({ limit: "50mb" }));
app.use(express.urlencoded({ extended: true }));

// --- Mobile user agent detection ---
function isMobileDevice(userAgent: string): boolean {
  return /iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
}

// --- Redirect mobile root -> /mobile (do NOT touch other paths) ---
app.use((req: Request, res: Response, next: NextFunction) => {
  const userAgent = req.headers["user-agent"] || "";
  if (req.method === "GET" && req.path === "/" && isMobileDevice(userAgent)) {
    log(`ðŸ“± Redirecting mobile browser from ${req.path} to /mobile`);
    return res.redirect(302, "/mobile");
  }
  next();
});

// --- API routes (mounted BEFORE SPA fallback) ---
await registerRoutes(app);

// --- SPA History Fallback for client routes ---
// why: Ensure /mobile and deep links render index.html via Vite (dev) or dist (prod)
const historyMiddleware = history({
  verbose: false,
  // preserve API and static asset requests
  rewrites: [
    { from: /^\/api\/.*$/, to: (ctx) => ctx.parsedUrl.path || "" },
    { from: /^\/assets\/.*$/, to: (ctx) => ctx.parsedUrl.path || "" },
  ],
});
app.use(historyMiddleware);

// --- Vite middleware (dev) + static (prod) ---
const server = app.listen(5000, "0.0.0.0", () => log("serving on port 5000"));
await setupVite(app, server);
serveStatic(app);

// --- Diagnostics ---
app.get("/health", (_req, res) => {
  // why: quick manual check; Safari -1015 usually indicates encoding mismatch
  res.type("text/plain").send("OK");
});

// NOTE: Remove any manual setting of 'Content-Encoding' or serving precompressed files
// unless the server sets the matching header automatically.


// File: server/vite.ts
// Purpose: Vite integration in middleware mode; ensure correct headers and no manual encoding

import type { Express } from "express";
import { createServer as createViteServer, ViteDevServer } from "vite";
import path from "node:path";
import fs from "node:fs";

export function log(msg: string) {
  // eslint-disable-next-line no-console
  console.log(`[server] ${msg}`);
}

export async function setupVite(app: Express, _server: import("node:http").Server) {
  // Only in development: use Vite middleware. In production, assets come from /dist
  const isProd = process.env.NODE_ENV === "production";
  if (isProd) return null as unknown as ViteDevServer;

  const vite = await createViteServer({
    server: { middlewareMode: true },
    appType: "custom", // disable Vite's own HTML serving logic
  });

  // why: Let Vite handle /@vite, /src, HMR, etc.
  app.use(vite.middlewares);

  // HTML entry (dev): send transformed index.html for any SPA route
  app.get(["/", "/mobile", "/mobile/*"], async (req, res, next) => {
    try {
      const indexHtmlPath = path.resolve(process.cwd(), "index.html");
      let html = await fs.promises.readFile(indexHtmlPath, "utf-8");
      html = await vite.transformIndexHtml(req.originalUrl, html);
      // Do NOT set content-encoding manually; compression() will handle it
      res.status(200).set({ "Content-Type": "text/html; charset=utf-8" }).end(html);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });

  return vite;
}

export function serveStatic(app: Express) {
  const isProd = process.env.NODE_ENV === "production";
  if (!isProd) return;

  const dist = path.resolve(process.cwd(), "dist");
  const assets = path.join(dist, "assets");

  // Static assets (no manual content-encoding!)
  app.use("/assets", (await import("express")).default.static(assets, {
    maxAge: "1y",
    setHeaders(res, filePath) {
      // why: Explicit content-type for Safari on common extensions
      if (filePath.endsWith(".js")) res.setHeader("Content-Type", "application/javascript; charset=utf-8");
      if (filePath.endsWith(".css")) res.setHeader("Content-Type", "text/css; charset=utf-8");
      if (filePath.endsWith(".svg")) res.setHeader("Content-Type", "image/svg+xml");
      // Never set Content-Encoding here; let compression() decide
    },
  }));

  // Index HTML for SPA routes in prod
  app.get(["/", "/mobile", "/mobile/*"], (_req, res) => {
    res.sendFile(path.join(dist, "index.html"));
  });
}

// --- Usage notes ---
// 1) Ensure NODE_ENV is set appropriately (dev vs prod).
// 2) If you previously served precompressed .br/.gz files, remove that logic for now.
// 3) Test on iOS Safari: visit /health (should display "OK"), then /mobile.
// 4) If -1015 persists, proxy or CDN is rewriting Content-Encoding; test directly against 0.0.0.0:5000.