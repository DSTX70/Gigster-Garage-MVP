import { storage } from "./storage";
import { sendInvoiceEmail } from "./emailService";
import { generateInvoicePDF } from "./pdfService";
import { format, addDays, addMonths, addWeeks, isAfter, isBefore, startOfDay } from "date-fns";
import type { Invoice, Client, TimeLog, Project, InsertInvoice } from "@shared/schema";

/**
 * Automated Invoicing Service
 * Handles recurring billing, automatic invoice generation, and payment reminders
 */

export interface RecurringInvoiceRule {
  id: string;
  name: string;
  clientId: string;
  templateData: Partial<InsertInvoice>;
  frequency: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';
  interval: number; // e.g., every 2 months
  nextGenerationDate: Date;
  isActive: boolean;
  autoSend: boolean;
  reminderDays: number[];
  createdAt: Date;
  updatedAt: Date;
}

export interface InvoiceReminderRule {
  id: string;
  name: string;
  triggerDays: number; // Days before/after due date (negative = before, positive = after)
  reminderType: 'gentle' | 'standard' | 'urgent' | 'final';
  isActive: boolean;
  customMessage?: string;
  createdAt: Date;
}

export interface AutoGenerationRule {
  id: string;
  name: string;
  trigger: 'time_log_threshold' | 'project_milestone' | 'monthly_retainer' | 'custom_schedule';
  conditions: Record<string, any>;
  templateData: Partial<InsertInvoice>;
  autoSend: boolean;
  isActive: boolean;
  createdAt: Date;
}

export class AutomatedInvoicingService {
  private recurringRules: Map<string, RecurringInvoiceRule> = new Map();
  private reminderRules: Map<string, InvoiceReminderRule> = new Map();
  private autoGenRules: Map<string, AutoGenerationRule> = new Map();
  private isRunning = false;
  private intervalId: NodeJS.Timeout | null = null;

  constructor() {
    this.initializeDefaultRules();
  }

  /**
   * Initialize default automation rules
   */
  private initializeDefaultRules() {
    // Default payment reminder schedule
    const defaultReminders: Omit<InvoiceReminderRule, 'id' | 'createdAt'>[] = [
      {
        name: "7-Day Advance Notice",
        triggerDays: -7,
        reminderType: 'gentle',
        isActive: true,
        customMessage: "Just a friendly reminder that your invoice is due in 7 days."
      },
      {
        name: "3-Day Advance Notice", 
        triggerDays: -3,
        reminderType: 'standard',
        isActive: true,
        customMessage: "Your invoice payment is due in 3 days. Please process payment at your earliest convenience."
      },
      {
        name: "Due Date Reminder",
        triggerDays: 0,
        reminderType: 'standard',
        isActive: true,
        customMessage: "Your invoice payment is due today. Please process payment to avoid any late fees."
      },
      {
        name: "3-Day Overdue Notice",
        triggerDays: 3,
        reminderType: 'urgent',
        isActive: true,
        customMessage: "Your invoice payment is now 3 days overdue. Please process payment immediately to avoid additional charges."
      },
      {
        name: "7-Day Overdue Final Notice",
        triggerDays: 7,
        reminderType: 'final',
        isActive: true,
        customMessage: "FINAL NOTICE: Your invoice payment is 7 days overdue. Immediate payment is required to avoid account suspension."
      }
    ];

    // Initialize reminder rules
    defaultReminders.forEach((rule, index) => {
      const ruleWithId = {
        ...rule,
        id: `reminder_${index + 1}`,
        createdAt: new Date()
      };
      this.reminderRules.set(ruleWithId.id, ruleWithId);
    });

    console.log(`üîî Initialized ${defaultReminders.length} default payment reminder rules`);
  }

  /**
   * Start the automated invoicing service
   */
  public startAutomatedInvoicing() {
    if (this.isRunning) {
      console.log("üìã Automated invoicing already running");
      return;
    }

    console.log("üöÄ Starting automated invoicing service");
    this.isRunning = true;

    // Run immediately on startup
    this.processAutomatedInvoicing();

    // Then run every 6 hours for comprehensive checks
    this.intervalId = setInterval(() => {
      this.processAutomatedInvoicing();
    }, 6 * 60 * 60 * 1000); // 6 hours
  }

  /**
   * Stop the automated invoicing service
   */
  public stopAutomatedInvoicing() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
    this.isRunning = false;
    console.log("‚èπÔ∏è Stopped automated invoicing service");
  }

  /**
   * Main processing function for automated invoicing
   */
  public async processAutomatedInvoicing() {
    try {
      console.log("üîÑ Processing automated invoicing...");
      
      const startTime = Date.now();
      let results = {
        recurringInvoicesGenerated: 0,
        autoGeneratedInvoices: 0,
        remindersSent: 0,
        errors: 0
      };

      // Process recurring invoices
      const recurringResults = await this.processRecurringInvoices();
      results.recurringInvoicesGenerated = recurringResults.generated;
      results.errors += recurringResults.errors;

      // Process automatic generation rules
      const autoGenResults = await this.processAutoGenerationRules();
      results.autoGeneratedInvoices = autoGenResults.generated;
      results.errors += autoGenResults.errors;

      // Process payment reminders
      const reminderResults = await this.processPaymentReminders();
      results.remindersSent = reminderResults.sent;
      results.errors += reminderResults.errors;

      const duration = Date.now() - startTime;
      console.log(`‚úÖ Automated invoicing complete in ${duration}ms:`, {
        recurringInvoices: results.recurringInvoicesGenerated,
        autoGenerated: results.autoGeneratedInvoices,
        remindersSent: results.remindersSent,
        errors: results.errors
      });

    } catch (error) {
      console.error("‚ùå Error during automated invoicing process:", error);
    }
  }

  /**
   * Process recurring invoice generation
   */
  private async processRecurringInvoices(): Promise<{generated: number, errors: number}> {
    const today = startOfDay(new Date());
    let generated = 0;
    let errors = 0;

    for (const rule of Array.from(this.recurringRules.values())) {
      if (!rule.isActive) continue;

      try {
        const nextGen = startOfDay(new Date(rule.nextGenerationDate));
        
        // Check if it's time to generate this recurring invoice
        if (isAfter(today, nextGen) || today.getTime() === nextGen.getTime()) {
          const invoice = await this.generateRecurringInvoice(rule);
          if (invoice) {
            generated++;
            
            // Update next generation date
            rule.nextGenerationDate = this.calculateNextGenerationDate(rule);
            
            // Auto-send if configured
            if (rule.autoSend) {
              await this.sendInvoiceWithRetry(invoice.id);
            }
          }
        }
      } catch (error) {
        console.error(`‚ùå Error processing recurring rule ${rule.id}:`, error);
        errors++;
      }
    }

    return { generated, errors };
  }

  /**
   * Process automatic generation rules
   */
  private async processAutoGenerationRules(): Promise<{generated: number, errors: number}> {
    let generated = 0;
    let errors = 0;

    for (const rule of Array.from(this.autoGenRules.values())) {
      if (!rule.isActive) continue;

      try {
        const shouldGenerate = await this.evaluateAutoGenerationRule(rule);
        if (shouldGenerate) {
          const invoice = await this.generateInvoiceFromRule(rule);
          if (invoice) {
            generated++;
            
            if (rule.autoSend) {
              await this.sendInvoiceWithRetry(invoice.id);
            }
          }
        }
      } catch (error) {
        console.error(`‚ùå Error processing auto generation rule ${rule.id}:`, error);
        errors++;
      }
    }

    return { generated, errors };
  }

  /**
   * Process payment reminders
   */
  private async processPaymentReminders(): Promise<{sent: number, errors: number}> {
    const today = startOfDay(new Date());
    let sent = 0;
    let errors = 0;

    // Get all unpaid invoices
    const invoices = await storage.getInvoices();
    const unpaidInvoices = invoices.filter(inv => 
      inv.status !== 'paid' && inv.status !== 'cancelled' && inv.dueDate
    );

    for (const invoice of unpaidInvoices) {
      const dueDate = startOfDay(new Date(invoice.dueDate!));
      const daysDifference = Math.floor((today.getTime() - dueDate.getTime()) / (24 * 60 * 60 * 1000));

      for (const rule of Array.from(this.reminderRules.values())) {
        if (!rule.isActive) continue;

        // Check if this reminder should be triggered today
        if (daysDifference === rule.triggerDays) {
          try {
            const reminderSent = await this.sendPaymentReminder(invoice, rule);
            if (reminderSent) {
              sent++;
            }
          } catch (error) {
            console.error(`‚ùå Error sending reminder for invoice ${invoice.id}:`, error);
            errors++;
          }
        }
      }
    }

    return { sent, errors };
  }

  /**
   * Generate a recurring invoice
   */
  private async generateRecurringInvoice(rule: RecurringInvoiceRule): Promise<Invoice | null> {
    try {
      const client = await storage.getClient(rule.clientId);
      if (!client) {
        console.error(`‚ùå Client ${rule.clientId} not found for recurring rule ${rule.id}`);
        return null;
      }

      // Generate invoice number
      const invoiceNumber = await this.generateInvoiceNumber();
      
      // Create invoice from template
      const invoiceData: InsertInvoice = {
        ...rule.templateData,
        invoiceNumber,
        clientId: rule.clientId,
        status: 'draft',
        createdAt: new Date(),
        updatedAt: new Date(),
        dueDate: format(addDays(new Date(), 30), 'yyyy-MM-dd'), // Default 30 days from now
      };

      const invoice = await storage.createInvoice(invoiceData);
      console.log(`‚ú® Generated recurring invoice ${invoice.invoiceNumber} for client ${client.name}`);
      
      return invoice;
    } catch (error) {
      console.error(`‚ùå Failed to generate recurring invoice for rule ${rule.id}:`, error);
      return null;
    }
  }

  /**
   * Send payment reminder with appropriate messaging
   */
  private async sendPaymentReminder(invoice: Invoice, rule: InvoiceReminderRule): Promise<boolean> {
    try {
      if (!invoice.clientId) {
        console.error(`‚ùå No client ID found for invoice ${invoice.id}`);
        return false;
      }
      const client = await storage.getClient(invoice.clientId);
      if (!client?.email) {
        console.error(`‚ùå No email found for client ${invoice.clientId}`);
        return false;
      }

      // Generate PDF for reminder
      const pdfBuffer = await generateInvoicePDF(invoice);
      
      // Customize subject and message based on reminder type
      const subject = this.getReminderSubject(invoice, rule);
      const message = rule.customMessage || this.getDefaultReminderMessage(rule);

      const sent = await sendInvoiceEmail(
        client.email,
        invoice,
        pdfBuffer,
        message,
        'dustinsparks@mac.com'
      );

      if (sent) {
        console.log(`üìß Sent ${rule.reminderType} reminder for invoice ${invoice.invoiceNumber} to ${client.email}`);
      }

      return sent;
    } catch (error) {
      console.error(`‚ùå Failed to send payment reminder:`, error);
      return false;
    }
  }

  /**
   * Calculate next generation date for recurring invoices
   */
  private calculateNextGenerationDate(rule: RecurringInvoiceRule): Date {
    const currentDate = new Date();
    
    switch (rule.frequency) {
      case 'daily':
        return addDays(currentDate, rule.interval);
      case 'weekly':
        return addWeeks(currentDate, rule.interval);
      case 'monthly':
        return addMonths(currentDate, rule.interval);
      case 'quarterly':
        return addMonths(currentDate, rule.interval * 3);
      case 'yearly':
        return addMonths(currentDate, rule.interval * 12);
      default:
        return addMonths(currentDate, 1);
    }
  }

  /**
   * Generate unique invoice number
   */
  private async generateInvoiceNumber(): Promise<string> {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    
    // Get existing invoices to find next sequential number
    const existingInvoices = await storage.getInvoices();
    const todayInvoices = existingInvoices.filter(inv => 
      inv.invoiceNumber?.startsWith(`GG-${year}${month}${day}`)
    );
    
    const nextNum = String(todayInvoices.length + 1).padStart(3, '0');
    return `GG-${year}${month}${day}-${nextNum}`;
  }

  /**
   * Get reminder subject based on type
   */
  private getReminderSubject(invoice: Invoice, rule: InvoiceReminderRule): string {
    const baseSubject = `Invoice ${invoice.invoiceNumber}`;
    
    switch (rule.reminderType) {
      case 'gentle':
        return `${baseSubject} - Friendly Payment Reminder`;
      case 'standard':
        return `${baseSubject} - Payment Reminder`;
      case 'urgent':
        return `${baseSubject} - URGENT: Overdue Payment Notice`;
      case 'final':
        return `${baseSubject} - FINAL NOTICE: Immediate Payment Required`;
      default:
        return `${baseSubject} - Payment Reminder`;
    }
  }

  /**
   * Get default reminder message
   */
  private getDefaultReminderMessage(rule: InvoiceReminderRule): string {
    switch (rule.reminderType) {
      case 'gentle':
        return "Hope you're doing well! Just a friendly reminder about the attached invoice.";
      case 'standard':
        return "This is a reminder about your outstanding invoice. Please process payment at your earliest convenience.";
      case 'urgent':
        return "Your invoice payment is now overdue. Please process payment immediately to avoid additional charges.";
      case 'final':
        return "FINAL NOTICE: Your invoice payment is significantly overdue. Immediate payment is required to avoid account suspension.";
      default:
        return "Please find your invoice attached. Payment is appreciated.";
    }
  }

  /**
   * Send invoice with retry logic
   */
  private async sendInvoiceWithRetry(invoiceId: string, maxRetries = 3): Promise<boolean> {
    let attempts = 0;
    
    while (attempts < maxRetries) {
      try {
        const invoice = await storage.getInvoice(invoiceId);
        if (!invoice?.clientId) {
          throw new Error(`No client ID found for invoice ${invoiceId}`);
        }
        const client = await storage.getClient(invoice.clientId);
        
        if (!client?.email) {
          throw new Error(`No email found for client ${invoice!.clientId}`);
        }

        const pdfBuffer = await generateInvoicePDF(invoice);
        const sent = await sendInvoiceEmail(client.email, invoice, pdfBuffer);
        
        if (sent) {
          // Update invoice status to sent
          await storage.updateInvoice(invoiceId, { status: 'sent' });
          return true;
        }
        
        attempts++;
      } catch (error) {
        attempts++;
        console.error(`‚ùå Attempt ${attempts} failed for invoice ${invoiceId}:`, error);
        
        if (attempts < maxRetries) {
          // Wait before retry (exponential backoff)
          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempts) * 1000));
        }
      }
    }
    
    console.error(`‚ùå Failed to send invoice ${invoiceId} after ${maxRetries} attempts`);
    return false;
  }

  /**
   * Evaluate auto generation rule conditions
   */
  private async evaluateAutoGenerationRule(rule: AutoGenerationRule): Promise<boolean> {
    switch (rule.trigger) {
      case 'time_log_threshold':
        return await this.checkTimeLogThreshold(rule.conditions);
      case 'project_milestone':
        return await this.checkProjectMilestone(rule.conditions);
      case 'monthly_retainer':
        return await this.checkMonthlyRetainer(rule.conditions);
      case 'custom_schedule':
        return await this.checkCustomSchedule(rule.conditions);
      default:
        return false;
    }
  }

  /**
   * Check time log threshold for auto generation
   */
  private async checkTimeLogThreshold(conditions: any): Promise<boolean> {
    // Implementation for time-based invoice generation
    // This would check if accumulated time logs exceed a threshold
    return false; // Placeholder
  }

  /**
   * Check project milestone completion
   */
  private async checkProjectMilestone(conditions: any): Promise<boolean> {
    // Implementation for milestone-based invoice generation
    return false; // Placeholder
  }

  /**
   * Check monthly retainer schedule
   */
  private async checkMonthlyRetainer(conditions: any): Promise<boolean> {
    // Implementation for retainer-based invoice generation
    return false; // Placeholder
  }

  /**
   * Check custom schedule conditions
   */
  private async checkCustomSchedule(conditions: any): Promise<boolean> {
    // Implementation for custom schedule-based generation
    return false; // Placeholder
  }

  /**
   * Generate invoice from auto generation rule
   */
  private async generateInvoiceFromRule(rule: AutoGenerationRule): Promise<Invoice | null> {
    // Implementation for generating invoices from rules
    return null; // Placeholder
  }

  // Public API methods for managing rules

  /**
   * Add recurring invoice rule
   */
  public addRecurringRule(rule: Omit<RecurringInvoiceRule, 'id' | 'createdAt' | 'updatedAt'>): string {
    const id = `recurring_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const fullRule: RecurringInvoiceRule = {
      ...rule,
      id,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    
    this.recurringRules.set(id, fullRule);
    console.log(`‚ú® Added recurring invoice rule: ${fullRule.name}`);
    return id;
  }

  /**
   * Add payment reminder rule
   */
  public addReminderRule(rule: Omit<InvoiceReminderRule, 'id' | 'createdAt'>): string {
    const id = `reminder_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const fullRule: InvoiceReminderRule = {
      ...rule,
      id,
      createdAt: new Date(),
    };
    
    this.reminderRules.set(id, fullRule);
    console.log(`üîî Added payment reminder rule: ${fullRule.name}`);
    return id;
  }

  /**
   * Add auto generation rule
   */
  public addAutoGenerationRule(rule: Omit<AutoGenerationRule, 'id' | 'createdAt'>): string {
    const id = `autogen_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const fullRule: AutoGenerationRule = {
      ...rule,
      id,
      createdAt: new Date(),
    };
    
    this.autoGenRules.set(id, fullRule);
    console.log(`‚ö° Added auto generation rule: ${fullRule.name}`);
    return id;
  }

  /**
   * Get all automation rules
   */
  public getAllRules() {
    return {
      recurring: Array.from(this.recurringRules.values()),
      reminders: Array.from(this.reminderRules.values()),
      autoGeneration: Array.from(this.autoGenRules.values()),
    };
  }

  /**
   * Manual trigger for testing and configuration
   */
  public async manualTrigger(): Promise<void> {
    console.log("üîß Manual automated invoicing trigger - Configuring enterprise invoice automation");
    
    // Add enterprise-grade recurring billing rules
    try {
      // Monthly enterprise client billing
      this.addRecurringRule({
        name: "Enterprise Client Monthly Billing",
        clientId: "enterprise_clients",
        templateData: {
          description: "Enterprise Monthly Billing - Net 15 Terms",
          notes: "Includes 2% early payment discount, 1.5% late fee",
          customData: {
            include_time_breakdown: true,
            include_milestone_progress: true
          }
        },
        frequency: 'monthly',
        interval: 1,
        nextGenerationDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // Tomorrow
        isActive: true,
        autoSend: true,
        reminderDays: [7, 3, 0, 3, 7] // Pre and post due date
      });

      // High-value project milestone billing
      this.addRecurringRule({
        name: "Milestone-Based Billing for Premium Projects",
        clientId: "premium_projects",
        templateData: {
          description: "Premium Project Milestone Billing - Net 10 Terms",
          notes: "Requires approval, includes deliverable summary",
          customData: {
            require_approval: true,
            include_deliverable_summary: true
          }
        },
        frequency: 'monthly',
        interval: 1,
        nextGenerationDate: new Date(),
        isActive: true,
        autoSend: false, // Requires manual review for high-value
        reminderDays: [5, 2, 0, 1]
      });

      // Enhanced payment reminder with escalation
      this.addReminderRule({
        name: "Enterprise Payment Escalation Protocol",
        triggerDays: 10, // 10 days overdue
        reminderType: 'urgent',
        isActive: true,
        customMessage: "URGENT: Payment overdue. Account may be suspended. Please contact our finance team immediately."
      });

      console.log("‚ú® Configured enterprise automated invoice generation with premium billing rules");
    } catch (error) {
      console.error('Error configuring invoice automation:', error);
    }
    
    await this.processAutomatedInvoicing();
  }
}

// Export singleton instance
export const automatedInvoicingService = new AutomatedInvoicingService();